// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/ReilEgor/Vaca/services/DataProcessorService/internal/broker/rabbitmq"
	"github.com/ReilEgor/Vaca/services/DataProcessorService/internal/config"
	"github.com/ReilEgor/Vaca/services/DataProcessorService/internal/domain"
	"github.com/ReilEgor/Vaca/services/DataProcessorService/internal/repository/elasticsearch"
	"github.com/ReilEgor/Vaca/services/DataProcessorService/internal/repository/postgres"
	"github.com/ReilEgor/Vaca/services/DataProcessorService/internal/repository/redis"
	"github.com/ReilEgor/Vaca/services/DataProcessorService/internal/usecase"
	"github.com/google/wire"
	"log/slog"
)

import (
	_ "github.com/ReilEgor/Vaca/pkg"
)

// Injectors from wire.go:

func InitializeApp(dsn string, rabbitURL rabbitmq.RabbitURL, searchRepoURL elasticsearch.ElasticSearchURL, qName rabbitmq.SubscriberQueueName, logger *slog.Logger) (*App, func(), error) {
	configConfig := config.NewConfig()
	client, err := redis.NewRedisClient(configConfig)
	if err != nil {
		return nil, nil, err
	}
	taskCache := redis.NewRedisTokenRepository(client)
	db, cleanup, err := postgres.NewPostgresDB(dsn)
	if err != nil {
		return nil, nil, err
	}
	vacancyRepository := postgres.NewVacancyRepository(db)
	typedClient, err := elasticsearch.NewElasticClient(searchRepoURL)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	vacancySearchRepository := elasticsearch.NewElasticRepository(typedClient)
	dataProcessorInteractor := usecase.NewDataProcessorInteractor(taskCache, vacancyRepository, vacancySearchRepository)
	connection, cleanup2, err := rabbitmq.NewRabbitMQConn(rabbitURL)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	channel, cleanup3, err := rabbitmq.NewRabbitMQChannel(connection)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	dataSubscriber := rabbitmq.NewTaskSubscriber(channel, dataProcessorInteractor, logger, qName)
	app := &App{
		Logic:      dataProcessorInteractor,
		Repository: vacancyRepository,
		Subscriber: dataSubscriber,
		Cache:      taskCache,
		SearchRepo: vacancySearchRepository,
	}
	return app, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

var UsecaseSet = wire.NewSet(usecase.NewDataProcessorInteractor, wire.Bind(new(domain.DataProcessorUsecase), new(*usecase.DataProcessorInteractor)))

var BrokerSet = wire.NewSet(rabbitmq.NewRabbitMQConn, rabbitmq.NewRabbitMQChannel, rabbitmq.NewTaskSubscriber, wire.Bind(new(domain.DataSubscriber), new(*rabbitmq.DataSubscriber)))

var RepositorySet = wire.NewSet(postgres.NewPostgresDB, postgres.NewVacancyRepository)

var InfraSet = wire.NewSet(config.NewConfig, redis.NewRedisClient, redis.NewRedisTokenRepository)

var ElasticSet = wire.NewSet(elasticsearch.NewElasticClient, elasticsearch.NewElasticRepository)

type App struct {
	Logic      domain.DataProcessorUsecase
	Repository domain.VacancyRepository
	Subscriber domain.DataSubscriber
	Cache      domain.TaskCache
	SearchRepo domain.VacancySearchRepository
}
